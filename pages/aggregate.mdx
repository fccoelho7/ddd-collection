# Aggregate

In Domain-Driven Design (DDD), an aggregate is a pattern used to cluster together a group of related entities and value objects into a single unit of consistency. Aggregates help maintain data integrity and enforce business rules by encapsulating the rules and constraints that apply to a specific part of the domain. Here are key points to understand about aggregates:

1. **Consistency Boundary**: Aggregates define a consistency boundary within which all the contained entities and value objects must maintain consistent and valid states. This means that changes to the data within the aggregate should adhere to the aggregate's rules and constraints.

2. **Root Entity**: Every aggregate has a root entity that serves as the entry point for interacting with the aggregate. The root entity is responsible for coordinating operations within the aggregate and enforcing its invariants. It is the only entity that can be accessed directly from outside the aggregate.

3. **Entities and Value Objects**: Aggregates are composed of entities and value objects. Entities are objects with identity, and value objects are objects without identity. Entities represent things that can change state over time, while value objects are immutable and can be freely shared. Both entities and value objects within an aggregate work together to ensure consistency.

4. **Transactional Boundaries**: Aggregates are often treated as transactional boundaries. This means that all changes to the data within an aggregate should be made within a single transaction or unit of work. If any part of the aggregate fails to meet its constraints, the entire operation should be rolled back.

5. **Direct Access**: Clients of the application can access and modify the aggregate only through the root entity. The root entity serves as the gatekeeper, ensuring that all changes and validations occur as a cohesive unit.

6. **Separation of Aggregates**: In DDD, different parts of the domain can be modeled as separate aggregates. Aggregates should be designed to minimize conflicts and contention between different parts of the domain to allow for efficient and scalable data management.

7. **Consistency and Performance**: Aggregates help strike a balance between consistency and performance. By limiting the scope of consistency to a smaller portion of the domain, they can enhance system scalability and responsiveness while still ensuring data integrity.

8. **Eventual Consistency**: Aggregates might not always be consistent with each other in real-time. Consistency can be achieved eventually through background processes or other mechanisms. The key is to ensure that each aggregate remains internally consistent.

Aggregates are a fundamental concept in DDD, and they play a crucial role in organizing and structuring the domain model of a software application. They help simplify the management of complex business rules and maintain data integrity in a domain-driven architecture. When designing aggregates, it's important to carefully define the boundaries and relationships between aggregates to ensure that they effectively model the real-world domain and support the requirements of the application.

## Example

```ts copy
class OrderLineItem {
  private _productId: string;
  private _quantity: number;

  constructor(productId: string, quantity: number) {
    this._productId = productId;
    this._quantity = quantity;
  }

  get productId(): string {
    return this._productId;
  }

  get quantity(): number {
    return this._quantity;
  }
}

class Order {
  private _orderId: string;
  private _lineItems: OrderLineItem[] = [];

  constructor(orderId: string) {
    this._orderId = orderId;
  }

  get orderId(): string {
    return this._orderId;
  }

  get lineItems(): OrderLineItem[] {
    return this._lineItems;
  }

  // Method to add a line item to the order
  addLineItem(productId: string, quantity: number) {
    const existingLineItem = this._lineItems.find(
      (item) => item.productId === productId
    );
    if (existingLineItem) {
      existingLineItem._quantity += quantity;
    } else {
      const newLineItem = new OrderLineItem(productId, quantity);
      this._lineItems.push(newLineItem);
    }
  }

  // Method to calculate the total order amount
  calculateTotalAmount(): number {
    let total = 0;
    for (const lineItem of this._lineItems) {
      // In a real application, you would fetch product prices and calculate the total amount here.
      // For simplicity, we'll assume a fixed price of $10 per product.
      total += lineItem.quantity * 10;
    }
    return total;
  }
}

// Example usage:
const order = new Order("1");
order.addLineItem("A123", 3);
order.addLineItem("B456", 2);
console.log(`Order ID: ${order.orderId}`);
console.log("Line Items:");
for (const lineItem of order.lineItems) {
  console.log(
    `Product ID: ${lineItem.productId}, Quantity: ${lineItem.quantity}`
  );
}
const totalAmount = order.calculateTotalAmount();
console.log(`Total Order Amount: $${totalAmount}`);
```
